package engine.android.util.ui;

import android.util.Pair;
import android.view.View;
import android.widget.TextView;

import engine.android.core.ApplicationManager;
import engine.android.core.Forelet;
import engine.android.core.Forelet.TextValidation;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * 验证模块
 * 
 * @author Daimon
 * @version N
 * @since 3/26/2012
 */
public class MyValidator {

    /** 不为空 */
    public static final Pattern VALID
    = Pattern.compile("\\S+");

    /** 中文 */
    public static final Pattern CHINESE
    = Pattern.compile("[\u4e00-\u9fa5]+");

    /** 双字节 */
    public static final Pattern DOUBLE_BYTE
    = Pattern.compile("[^\\x00-\\xff]+");

    /** 英文 */
    public static final Pattern ENGLISH
    = Pattern.compile("[A-Za-z]+");

    /** 数字 */
    public static final Pattern NUMERIC
    = Pattern.compile("\\d+");

    /** 整数 */
    public static final Pattern INTEGER
    = Pattern.compile("[+-]?\\d+$");

    /** 实数 */
    public static final Pattern REAL
    = Pattern.compile("^([+-]?\\d+)(\\.\\d+)?$");

    /** 小数 */
    public static final Pattern DECIMAL
    = Pattern.compile("^[+-]?\\d*\\.\\d+$");

    /** 手机号码 */
    public static final Pattern MOBILE_NUMBER
    = Pattern.compile("^((\\+86)|(86))?1\\d{10}$");

    /** 电话号码 */
    public static final Pattern PHONE_NUMBER
    = Pattern.compile(                                  // sdd = space, dot, or dash
            "(\\+[0-9]+[\\- \\.]*)?"                    // +<digits><sdd>*
          + "(\\([0-9]+\\)[\\- \\.]*)?"                 // (<digits>)<sdd>*
          + "([0-9][0-9\\- \\.][0-9\\- \\.]+[0-9])");   // <digit><digit|sdd>+<digit>

    /** 邮箱地址 */
    public static final Pattern EMAIL_ADDRESS
    = Pattern.compile(
            "[a-zA-Z0-9\\+\\.\\_\\%\\-\\+]{1,256}" +
            "\\@" +
            "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,64}" +
            "(" +
            "\\." +
            "[a-zA-Z0-9][a-zA-Z0-9\\-]{0,25}" +
            ")+"
            );

    /** IP地址 */
    public static final Pattern IP_ADDRESS
    = Pattern.compile(
            "((25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(25[0-5]|2[0-4]"
          + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1]"
          + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
          + "|[1-9][0-9]|[0-9]))"
          );

    /**
     *  Regular expression to match all IANA top-level domains.
     *  List accurate as of 2010/02/05.  List taken from:
     *  http://data.iana.org/TLD/tlds-alpha-by-domain.txt
     *  This pattern is auto-generated by 
     *  frameworks/base/common/tools/make-iana-tld-pattern.py
     */
    
    private static final String TOP_LEVEL_DOMAIN_STR =
            "((aero|arpa|asia|a[cdefgilmnoqrstuwxz])"
          + "|(biz|b[abdefghijmnorstvwyz])"
          + "|(cat|com|coop|c[acdfghiklmnoruvxyz])"
          + "|d[ejkmoz]"
          + "|(edu|e[cegrstu])"
          + "|f[ijkmor]"
          + "|(gov|g[abdefghilmnpqrstuwy])"
          + "|h[kmnrtu]"
          + "|(info|int|i[delmnoqrst])"
          + "|(jobs|j[emop])"
          + "|k[eghimnprwyz]"
          + "|l[abcikrstuvy]"
          + "|(mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])"
          + "|(name|net|n[acefgilopruz])"
          + "|(org|om)"
          + "|(pro|p[aefghklmnrstwy])"
          + "|qa"
          + "|r[eosuw]"
          + "|s[abcdeghijklmnortuvyz]"
          + "|(tel|travel|t[cdfghjklmnoprtvwz])"
          + "|u[agksyz]"
          + "|v[aceginu]"
          + "|w[fs]"
          + "|(xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g" +
            "|xn\\-\\-80akhbyknj4f|xn\\-\\-9t4b11yi5a" +
            "|xn\\-\\-deba0ad|xn\\-\\-g6w251d" +
            "|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a" +
            "|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-zckzah)"
          + "|y[etu]"
          + "|z[amw])";

    /**
     * Regular expression pattern to match all IANA top-level domains.
     */
    
    private static final Pattern TOP_LEVEL_DOMAIN =
            Pattern.compile(TOP_LEVEL_DOMAIN_STR);

    /**
     *  Regular expression to match all IANA top-level domains for WEB_URL.
     *  List accurate as of 2010/02/05.  List taken from:
     *  http://data.iana.org/TLD/tlds-alpha-by-domain.txt
     *  This pattern is auto-generated by 
     *  frameworks/base/common/tools/make-iana-tld-pattern.py
     */
    
    private static final String TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL =
            "(?:"
          + "(?:aero|arpa|asia|a[cdefgilmnoqrstuwxz])"
          + "|(?:biz|b[abdefghijmnorstvwyz])"
          + "|(?:cat|com|coop|c[acdfghiklmnoruvxyz])"
          + "|d[ejkmoz]"
          + "|(?:edu|e[cegrstu])"
          + "|f[ijkmor]"
          + "|(?:gov|g[abdefghilmnpqrstuwy])"
          + "|h[kmnrtu]"
          + "|(?:info|int|i[delmnoqrst])"
          + "|(?:jobs|j[emop])"
          + "|k[eghimnprwyz]"
          + "|l[abcikrstuvy]"
          + "|(?:mil|mobi|museum|m[acdeghklmnopqrstuvwxyz])"
          + "|(?:name|net|n[acefgilopruz])"
          + "|(?:org|om)"
          + "|(?:pro|p[aefghklmnrstwy])"
          + "|qa"
          + "|r[eosuw]"
          + "|s[abcdeghijklmnortuvyz]"
          + "|(?:tel|travel|t[cdfghjklmnoprtvwz])"
          + "|u[agksyz]"
          + "|v[aceginu]"
          + "|w[fs]"
          + "|(?:xn\\-\\-0zwm56d|xn\\-\\-11b5bs3a9aj6g" +
            "|xn\\-\\-80akhbyknj4f|xn\\-\\-9t4b11yi5a" +
            "|xn\\-\\-deba0ad|xn\\-\\-g6w251d" +
            "|xn\\-\\-hgbk6aj7f53bba|xn\\-\\-hlcj6aya9esc7a" +
            "|xn\\-\\-jxalpdlp|xn\\-\\-kgbechtv|xn\\-\\-zckzah)"
          + "|y[etu]"
          + "|z[amw]))";

    /**
     * Good characters for Internationalized Resource Identifiers (IRI).
     * This comprises most common used Unicode characters allowed in IRI
     * as detailed in RFC 3987.
     * Specifically, those two byte Unicode characters are not included.
     */
    
    private static final String GOOD_IRI_CHAR =
            "a-zA-Z0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF";

    /**
     * 网址<br>
     * Regular expression pattern to match most part of RFC 3987
     * Internationalized URLs, aka IRIs. Commonly used Unicode characters are
     * added.
     */
    
    public static final Pattern WEB_URL
    = Pattern.compile(
            "((?:(http|https|Http|Https|rtsp|Rtsp|ftp|Ftp):"
          + "\\/\\/(?:(?:[a-zA-Z0-9\\$\\-\\_\\.\\+\\!\\*\\'\\(\\)"
          + "\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,64}(?:\\:(?:[a-zA-Z0-9\\$\\-\\_"
          + "\\.\\+\\!\\*\\'\\(\\)\\,\\;\\?\\&\\=]|(?:\\%[a-fA-F0-9]{2})){1,25})?\\@)?)?"
          + "((?:(?:[" + GOOD_IRI_CHAR + "][" + GOOD_IRI_CHAR + "\\-]{0,64}\\.)+"   // named host
          + TOP_LEVEL_DOMAIN_STR_FOR_WEB_URL
          + "|(?:(?:25[0-5]|2[0-4]"                                                 // or ip address
          + "[0-9]|[0-1][0-9]{2}|[1-9][0-9]|[1-9])\\.(?:25[0-5]|2[0-4][0-9]"
          + "|[0-1][0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1]"
          + "[0-9]{2}|[1-9][0-9]|[1-9]|0)\\.(?:25[0-5]|2[0-4][0-9]|[0-1][0-9]{2}"
          + "|[1-9][0-9]|[0-9])))"
          + "(?:\\:\\d{1,5})?)"                                            // plus option port number
          + "(\\/(?:(?:[" + GOOD_IRI_CHAR + "\\;\\/\\?\\:\\@\\&\\=\\#\\~"  // plus option query params
          + "\\-\\.\\+\\!\\*\\'\\(\\)\\,\\_])|(?:\\%[a-fA-F0-9]{2}))*)?"
          + "(?:\\b|$)");           // and finally, a word boundary or end of
                                    // input. This is to stop foo.sure from
                                    // matching as foo.su

    /** 域名 */
    public static final Pattern DOMAIN_NAME
    = Pattern.compile(
            "((((["
          + GOOD_IRI_CHAR + "]["
          + GOOD_IRI_CHAR + "\\-]*)*["
          + GOOD_IRI_CHAR + "]\\.)+"
          + TOP_LEVEL_DOMAIN + ")|"
          + IP_ADDRESS + ")");

    /** 邮政编码 */
    public static final Pattern POSTAL
    = Pattern.compile("[1-9]\\d{5}(?!\\d)");

    /** 身份证号码 */
    public static final Pattern IDCARD
    = Pattern.compile("\\d{15}|(\\d{17}[0-9a-zA-Z])");

    /** QQ号码 */
    public static final Pattern QQ
    = Pattern.compile("[1-9][0-9]{4,}");

    /** HTML标记 */
    public static final Pattern HTML
    = Pattern.compile("<(\\S*?)[^>]*>.*?</\1>|<.*? />");

    /** 车牌号 */
    public static final Pattern CAR_NUMBER
    = Pattern.compile("^[\u4e00-\u9fa5][A-M]-[A-Z0-9][0-9]{4}$");

    /** 日期 */
    public static final Pattern DATE
    = Pattern.compile(
            "^(?:(?:1[6-9]|[2-9]\\d)?\\d{2}" +
    		"[\\/\\-\\.](?:0?[1,3-9]|1[0-2])[\\/\\-\\.]" +
    		"(?:29|30))(?: (?:0?\\d|1\\d|2[0-3])\\:" +
    		"(?:0?\\d|[1-5]\\d)\\:(?:0?\\d|[1-5]\\d)" +
    		"(?: \\d{1,3})?)?$|^(?:(?:1[6-9]|[2-9]\\d)?\\d{2}" +
    		"[\\/\\-\\.](?:0?[1,3,5,7,8]|1[02])[\\/\\-\\.]31)" +
    		"(?: (?:0?\\d|1\\d|2[0-3])\\:(?:0?\\d|[1-5]\\d)\\:" +
    		"(?:0?\\d|[1-5]\\d)(?: \\d{1,3})?)?$|^(?:(?:1[6-9]|[2-9]\\d)?" +
    		"(?:0[48]|[2468][048]|[13579][26])[\\/\\-\\.]0?2[\\/\\-\\.]29)" +
    		"(?: (?:0?\\d|1\\d|2[0-3])\\:(?:0?\\d|[1-5]\\d)\\:" +
    		"(?:0?\\d|[1-5]\\d)(?: \\d{1,3})?)?$|^(?:(?:16|[2468][048]|[3579][26])" +
    		"00[\\/\\-\\.]0?2[\\/\\-\\.]29)(?: (?:0?\\d|1\\d|2[0-3])\\:" +
    		"(?:0?\\d|[1-5]\\d)\\:(?:0?\\d|[1-5]\\d)(?: \\d{1,3})?)?$|^" +
    		"(?:(?:1[6-9]|[2-9]\\d)?\\d{2}[\\/\\-\\.](?:0?[1-9]|1[0-2])" +
    		"[\\/\\-\\.](?:0?[1-9]|1\\d|2[0-8]))(?: (?:0?\\d|1\\d|2[0-3])\\:" +
    		"(?:0?\\d|[1-5]\\d)\\:(?:0?\\d|[1-5]\\d)(?: \\d{1,3})?)?$");

    /**
     * 小数，参数为保留小数点后n位
     */
    public static Pattern patternDecimal(int n) {
        if (n <= 0)
        {
            throw new IllegalArgumentException();
        }

        return Pattern.compile(String.format("^[+-]?\\d*\\.\\d{%d}$", n));
    }

    /**
     * 账号，参数为允许min到max个字符数
     */
    public static Pattern patternAccount(int min, int max) {
        if (min < 1 || max < 1 || min > max)
        {
            throw new IllegalArgumentException();
        }

        return Pattern.compile(String.format("^[a-zA-Z][a-zA-Z0-9_]{%d,%d}$", min - 1, max - 1));
    }

    /**
     * 验证方法
     */
    public static boolean validate(String s, Pattern p) {
        return p.matcher(s).matches();
    }

    /**
     * 解析文本样式
     */
    public static List<PatternText> parse(String s, Pattern p) {
        Matcher m = p.matcher(s);
        boolean flag = m.find();
        if (flag)
        {
            List<PatternText> list = new ArrayList<PatternText>();
            do
            {
                list.add(new PatternText(m.start(), m.end(), m.group()));
            } while (flag = m.find(m.end()));
            
            return list;
        }

        return null;
    }
    
    public static final class PatternText {
        
        public final int start;
        public final int end;
        public final String text;
        
        public PatternText(int start, int end, String text) {
            this.start = start;
            this.end = end;
            this.text = text;
        }
    }

    public static class PatternValidation<T extends TextView> extends TextValidation<T> {

        private final Pattern pattern;

        public PatternValidation(Pattern pattern) {
            this.pattern = pattern;
        }

        @Override
        public boolean isValid(String s) {
            return validate(s, pattern);
        }
    }

    public static class Validation<T extends View> implements Forelet.Validation<T> {

        private final LinkedList<Pair<Forelet.Validation<T>, String>> validations
        = new LinkedList<Pair<Forelet.Validation<T>, String>>();

        public final Validation<T> addValidation(Forelet.Validation<T> validation, String invalidText) {
            validations.add(new Pair<Forelet.Validation<T>, String>(validation, invalidText));
            return this;
        }

        protected void showInvalidText(String invalidText) {
            ApplicationManager.showMessage(invalidText);
        }

        @Override
        public boolean isValid(T view) {
            for (Pair<Forelet.Validation<T>, String> pair : validations)
            {
                if (!pair.first.isValid(view))
                {
                    showInvalidText(pair.second);
                    return false;
                }
            }

            return true;
        }
    }
}